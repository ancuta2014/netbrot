# SPDX-FileCopyrightText: 2024 Alexandru Fikl <alexfikl@gmail.com>
# SPDX-License-Identifier: MIT

from __future__ import annotations

import logging
import pathlib
from dataclasses import dataclass
from typing import Any

import jinja2
import numpy as np
import rich.logging
import sympy as sp

log = logging.getLogger(pathlib.Path(__file__).stem)
log.setLevel(logging.ERROR)
log.addHandler(rich.logging.RichHandler())

Array = np.ndarray[Any, np.dtype[Any]]
Matrix = Array


# {{{ code generation

TEMPLATE = """\
// SPDX-FileCopyrightText: 2024 Alexandru Fikl <alexfikl@gmail.com>
// SPDX-License-Identifier: MIT

// NOTE: This file was generated by `generate-coefficients-eval.py` and
// should not be modified.

use num::complex::{c64, Complex64};

use crate::netbrot::Matrix;

((( for item in items -)))
pub fn ((* item.name *))(mat: &Matrix, c: Complex64) -> ((* item.return_type *)) {
(((- if item.is_matrix_symbolic )))
    (((- for row in item.mat -)))
        ((( set i = loop.index0 )))
        (((- for element in row -)))
            ((( set j = loop.index0 )))
    let a_((* i *))_((* j *)) = mat[( ((* i *)), ((* j *)) )];
        (((- endfor -)))
    (((- endfor )))
(((- endif )))

    [
    (((- for coeffs in item.coefficients -)))
    [
    (((- for pows, coeff in coeffs )))
        ( ((* pows *)), ((* coeff | to_rust *)) ),
    (((- endfor )))
    ],
    (((- endfor -)))
    ]
}
((( endfor )))
"""


class SympyToRustStringifier:
    def __call__(self, expr: sp.Expr) -> str:
        result = self.rec(expr)

        try:
            num = float(result)
            return f"c64({num}, 0.0)"
        except ValueError:
            return result

    def rec(self, expr: sp.Expr) -> str:
        name = type(expr).__name__
        method_name = f"map_{name}"

        try:
            method = getattr(self, method_name)
        except AttributeError:
            pass
        else:
            return method(expr)

        raise NotImplementedError(f"Cannot stringify type '{type(expr).__name__}'")

    def map_Symbol(self, expr: sp.Symbol) -> str:  # noqa: N802,PLR6301
        return str(expr.name)

    def map_Integer(self, expr: sp.Integer) -> str:  # noqa: N802,PLR6301
        return str(expr)

    def map_Float(self, expr: sp.Float) -> str:  # noqa: N802,PLR6301
        return f"{float(expr):e}"

    def map_Add(self, expr: sp.Add) -> str:  # noqa: N802
        return " + ".join(self.rec(arg) for arg in expr.args)

    def map_Mul(self, expr: sp.Mul) -> str:  # noqa: N802
        return " * ".join(self.rec(arg) for arg in expr.args)

    def map_Pow(self, expr: sp.Pow) -> str:  # noqa: N802
        base, exp = expr.args

        if isinstance(exp, (int, sp.Integer)):
            return f"{self.rec(base)}.powi({self.rec(exp)})"
        else:
            return f"{self.rec(base)}.pow({self.rec(exp)})"


def to_rust(expr: sp.Expr) -> str:
    return SympyToRustStringifier()(expr)


def make_jinja_env() -> jinja2.Environment:
    env = jinja2.Environment(
        block_start_string="(((",
        block_end_string=")))",
        variable_start_string="((*",
        variable_end_string="*))",
        comment_start_string="((=",
        comment_end_string="=))",
        autoescape=True,
    )
    env.filters["to_rust"] = to_rust

    return env


# }}}


# {{{ netbrot


@dataclass(frozen=True)
class Coefficient:
    period: int
    mat: Matrix

    coefficients: list[list[tuple[tuple[int, ...], sp.Expr]]]

    @property
    def name(self) -> str:
        period = self.period
        ndim = self.ndim
        return f"coeffs_{ndim}x{ndim}_{period}"

    @property
    def return_type(self) -> str:
        ndim = self.ndim
        ncoeffs = self.ncoeffs
        return f"[[([u32; {ndim}], Complex64); {ncoeffs}]; {ndim}]"

    @property
    def ndim(self) -> int:
        n = len(self.coefficients)
        assert self.mat.shape == (n, n)

        return n

    @property
    def ncoeffs(self) -> int:
        n = len(self.coefficients[0])
        assert all(len(c) == n for c in self.coefficients[1:])

        return n

    @property
    def is_matrix_symbolic(self) -> int:
        try:
            float(self.mat[0, 0])
            return False
        except TypeError:
            return True


def netbrot(z: Array, mat: Matrix, c: complex) -> Array:
    return (mat @ z) ** 2 + c


def get_poly_coefficients(eq: sp.Poly, z: Array) -> dict[tuple[int, ...], sp.Expr]:
    return {
        pows: sp.simplify(
            eq.coeff_monomial(sp.prod([z_i**n_i for z_i, n_i in zip(z, pows)]))
        )
        for pows in eq.monoms()
    }


def make_coefficients(nperiods: int, ndim: int, *, infile: pathlib.Path | None = None):
    c = sp.Symbol("c", complex=True)
    z = np.array(sp.symbols([f"z_{i}" for i in range(ndim)], complex=True))

    if infile is not None:
        if not infile.exists():
            log.error("File does not exist: '%s'.", infile)
            return 1

        import json

        with open(infile, encoding="utf-8") as inf:
            data = json.load(inf)

        elements, *shape = data["mat"]
        if shape[0] != shape[1]:
            log.error("Matrix expected to be square: %s", shape)
            return 1

        if shape[0] != ndim:
            log.error("Expected a matrix of shape (%d, %d): %s", ndim, ndim, shape)

        mat = (
            np.array([sp.Rational(str(e_r)) for e_r, _ in elements])
            .reshape(ndim, ndim)
            .T
        )

        domains = [sp.CC[c] for _ in range(ndim)]
    else:
        mat = np.array(
            sp.symbols(
                [f"a_{i}_{j}" for i in range(ndim) for j in range(ndim)],
                rational=True,
            )
        ).reshape(ndim, ndim)

        domains = [sp.CC[c, *mat.flatten()] for i in range(ndim)]

    result = []
    for nperiod in range(1, nperiods + 1):
        #  evaluate composition
        f = netbrot(z, mat, c)
        for _ in range(1, nperiod):
            f = netbrot(f, mat, c)
        f -= z

        # get coefficients
        equations = [
            sp.Poly(sp.expand(f[i]), *z, domain=domains[i]) for i in range(ndim)
        ]
        coefficients = [get_poly_coefficients(eq, z) for eq in equations]

        log.info("Period %d", nperiod)
        for i in range(ndim):
            log.info("Equation: %s", equations[i])
            log.info("Coefficients: %s", coefficients[i])
        log.info("")

        result.append(
            Coefficient(
                period=nperiod,
                mat=mat,
                coefficients=[
                    [(list(pows), expr) for pows, expr in coeffs.items()]
                    for coeffs in coefficients
                ],
            )
        )

    return result


# }}}


# {{{ main


def main(
    nperiods: int,
    ndim: int,
    *,
    infile: pathlib.Path | None = None,
    outfile: pathlib.Path | None = None,
    overwrite: bool = True,
) -> int:
    if nperiods < 0:
        log.error("Negative periods are not allowed: %d", nperiods)
        return 1

    if ndim <= 1:
        log.error("Dimension should be >= 2: %d", ndim)
        return 1

    if not overwrite and outfile is not None and outfile.exists():
        log.error("Output file exists (use --overwrite): %s.", outfile)
        return 1

    coefficients = make_coefficients(nperiods, ndim, infile=infile)

    env = make_jinja_env()
    result = env.from_string(TEMPLATE).render(items=coefficients)

    if outfile is None:
        print(result)
    else:
        with open(outfile, "w", encoding="utf-8") as outf:
            outf.write(result)

        log.info("Written code to '%s'.", outfile)

    return 0


# }}}


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-n",
        default=1,
        type=int,
        help="Maximum number of compositions to generate",
    )
    parser.add_argument(
        "-d",
        default=2,
        type=int,
        help="Dimension of the system to consider, e.g. a 2x2 system",
    )
    parser.add_argument(
        "-i",
        "--infile",
        type=pathlib.Path,
        default=None,
        help="A JSON file containing matrix coefficients to use",
    )
    parser.add_argument(
        "-o",
        "--outfile",
        type=pathlib.Path,
        default=None,
        help="A Rust source code file name for the generate code",
    )
    parser.add_argument(
        "-q",
        "--quiet",
        action="store_true",
        help="Only show error messages",
    )
    args = parser.parse_args()

    if not args.quiet:
        log.setLevel(logging.INFO)

    raise SystemExit(main(args.n, args.d, infile=args.infile, outfile=args.outfile))
